<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Distributed Sensor Hub</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>

<style>
:root {
	--bg: #0f1115;
	--panel: #161922;
	--border: #2a2f45;
	--text: #e6e6eb;
	--muted: #9aa0b4;
	--accent: #5eead4;
	--danger: #fb7185;
}

* { box-sizing: border-box; }

body {
	margin: 0;
	padding: 24px;
	font-family: Inter, system-ui, sans-serif;
	background: var(--bg);
	color: var(--text);
}

header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 20px;
}

h1 {
	font-size: 22px;
	font-weight: 600;
	margin: 0;
}

#status {
	font-size: 14px;
	color: var(--muted);
}

.controls {
	display: flex;
	gap: 12px;
	flex-wrap: wrap;
	margin-bottom: 24px;
}

input, button {
	background: var(--panel);
	border: 1px solid var(--border);
	color: var(--text);
	padding: 8px 10px;
	border-radius: 6px;
	font-size: 14px;
}

button { cursor: pointer; }

main {
	display: grid;
	grid-template-columns: 2fr 1fr;
	gap: 24px;
	align-items: start;
}

/* ---------------- Nodes ---------------- */

#nodes {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
	gap: 16px;
}

.node-card {
	background: var(--panel);
	border: 1px solid var(--border);
	border-radius: 10px;
	padding: 14px;
}

.node-header h2 {
	font-size: 15px;
	margin: 0 0 10px 0;
	font-weight: 600;
}

.sensor {
	display: flex;
	justify-content: space-between;
	padding: 6px 0;
	border-bottom: 1px dashed var(--border);
	font-size: 13px;
}

.sensor:last-child { border-bottom: none; }
.sensor .id { color: var(--muted); }
.sensor.updated { color: var(--accent); }

/* ---------------- Log ---------------- */

#log {
	background: var(--panel);
	border: 1px solid var(--border);
	border-radius: 10px;
	padding: 14px;
	display: flex;
	flex-direction: column;
	height: 520px;
	overflow: hidden;
}

#log h2 {
	font-size: 15px;
	margin: 0 0 10px 0;
	font-weight: 600;
}

#log-entries {
	flex: 1;
	overflow-y: auto;
	font-size: 12px;
	line-height: 1.4;
	color: var(--muted);
}

.log-entry {
	padding: 4px 0;
	border-bottom: 1px dashed var(--border);
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.log-entry:last-child { border-bottom: none; }
</style>
</head>

<body>

<header>
	<h1>Distributed Sensor Hub</h1>
	<div id="status">Disconnected</div>
</header>

<div class="controls">
	<input id="base-url" value="http://localhost:10000" size="28">
	<input id="refresh-ms" type="number" value="1000" min="200" step="100">
	<button id="apply">Apply</button>
</div>

<main>
	<section id="nodes"></section>

	<section id="log">
		<h2>Updates log</h2>
		<div id="log-entries"></div>
	</section>
</main>

<script>
"use strict";

lucide.createIcons();

const statusEl = document.getElementById("status");
const nodesEl = document.getElementById("nodes");
const logEl = document.getElementById("log-entries");

const baseUrlInput = document.getElementById("base-url");
const refreshMsInput = document.getElementById("refresh-ms");
const applyBtn = document.getElementById("apply");

let timer = null;
let currentBaseUrl = null;

/* DOM caches */
const nodeCards = new Map();
const sensorRows = new Map();

/* Log buffers */
const LOG_MAX = 300;
const logSeen = new Set();
const logBuffer = [];

function api(path) {
	return currentBaseUrl + path;
}

function setStatus(ok) {
	statusEl.textContent = ok ? "Connected" : "Disconnected";
	statusEl.style.color = ok ? "var(--accent)" : "var(--danger)";
}

function fmtTs(ts) {
	return new Date(ts).toLocaleTimeString();
}

function formatValue(data) {
	const unit = data && data.meta && data.meta.unit ? " " + data.meta.unit : "";
	return String(data.value) + unit;
}

/* ---------------- RESET ---------------- */

function resetUI() {
	if (timer) {
		clearInterval(timer);
		timer = null;
	}

	nodesEl.innerHTML = "";
	logEl.innerHTML = "";

	nodeCards.clear();
	sensorRows.clear();
	logSeen.clear();
	logBuffer.length = 0;

	setStatus(false);
}

/* ---------------- DOM HELPERS ---------------- */

function getNodeCard(nodeId) {
	let card = nodeCards.get(nodeId);
	if (card) return card;

	card = document.createElement("div");
	card.className = "node-card";
	card.innerHTML = `
		<div class="node-header">
			<h2>${nodeId}</h2>
		</div>
		<div class="sensors"></div>
	`;

	nodeCards.set(nodeId, card);
	nodesEl.appendChild(card);
	return card;
}

function getSensorRow(nodeId, sensorId) {
	const key = nodeId + "|" + sensorId;
	let row = sensorRows.get(key);
	if (row) return row;

	const card = getNodeCard(nodeId);
	const container = card.querySelector(".sensors");

	row = document.createElement("div");
	row.className = "sensor";
	row.innerHTML = `
		<span class="id"></span>
		<span class="val"></span>
	`;

	sensorRows.set(key, row);
	container.appendChild(row);
	return row;
}

/* ---------------- BACKEND SHAPE NORMALIZATION ---------------- */

/*
Backend (current) returns:
	state: { "<local_node_id>": { "<origin>:<sensor_id>": record, ... } }
	updates: same shape, but only deltas since last read

This UI wants:
	{ "<origin>": { "<sensor_id>": record, ... } }

We normalize both /api/state and /api/updates to the grouped-by-origin shape.
*/

function splitGlobalSensorId(globalId) {
	if (typeof globalId !== "string") return null;
	const idx = globalId.indexOf(":");
	if (idx <= 0) return null;
	return {
		origin: globalId.slice(0, idx),
		sensorId: globalId.slice(idx + 1),
	};
}

function normalizeGroupedByOrigin(payload) {
	if (!payload || typeof payload !== "object") return {};

	const topValues = Object.values(payload);
	let flatMap = null;

	if (topValues.length === 1 && topValues[0] && typeof topValues[0] === "object") {
		flatMap = topValues[0];
	} else {
		flatMap = {};
		for (const v of topValues) {
			if (v && typeof v === "object") {
				Object.assign(flatMap, v);
			}
		}
	}

	const grouped = {};
	for (const [globalId, rec] of Object.entries(flatMap)) {
		const parts = splitGlobalSensorId(globalId);
		if (!parts) continue;

		if (!grouped[parts.origin]) grouped[parts.origin] = {};
		grouped[parts.origin][parts.sensorId] = rec;
	}

	return grouped;
}

/* ---------------- STATE RENDER ---------------- */

function renderState(rawState, rawUpdates) {
	const state = normalizeGroupedByOrigin(rawState);
	const updates = normalizeGroupedByOrigin(rawUpdates);

	for (const [nodeId, sensors] of Object.entries(state)) {
		for (const [sensorId, data] of Object.entries(sensors)) {
			const row = getSensorRow(nodeId, sensorId);

			const isUpdated =
				updates[nodeId] &&
				updates[nodeId][sensorId] &&
				updates[nodeId][sensorId].ts_ms === data.ts_ms;

			row.querySelector(".id").textContent = sensorId;
			row.querySelector(".val").textContent = formatValue(data);
			row.classList.toggle("updated", isUpdated);
		}
	}
}

/* ---------------- LOG ---------------- */

function pushLog(nodeId, sensorId, data) {
	const key = `${nodeId}|${sensorId}|${data.ts_ms}`;
	if (logSeen.has(key)) return;

	logSeen.add(key);
	logBuffer.unshift({
		ts: data.ts_ms,
		nodeId,
		sensorId,
		value: formatValue(data)
	});

	while (logBuffer.length > LOG_MAX) {
		const e = logBuffer.pop();
		logSeen.delete(`${e.nodeId}|${e.sensorId}|${e.ts}`);
	}
}

function flushLog() {
	logEl.innerHTML = "";
	for (const e of logBuffer) {
		const line = document.createElement("div");
		line.className = "log-entry";
		line.textContent = `[${fmtTs(e.ts)}] ${e.nodeId} ${e.sensorId} -> ${e.value}`;
		logEl.appendChild(line);
	}
}

/* ---------------- POLLING ---------------- */

async function poll() {
	try {
		const [stateRes, updatesRes] = await Promise.all([
			fetch(api("/api/state"), { cache: "no-store" }),
			fetch(api("/api/updates"), { cache: "no-store" })
		]);

		if (!stateRes.ok || !updatesRes.ok) throw new Error();

		const rawState = await stateRes.json();
		const rawUpdates = await updatesRes.json();

		renderState(rawState, rawUpdates);

		const updates = normalizeGroupedByOrigin(rawUpdates);
		for (const [n, ss] of Object.entries(updates)) {
			for (const [s, d] of Object.entries(ss)) {
				pushLog(n, s, d);
			}
		}

		flushLog();
		setStatus(true);
	} catch {
		setStatus(false);
	}
}

/* ---------------- START ---------------- */

function start() {
	const newBase = baseUrlInput.value.replace(/\/+$/, "");

	if (newBase !== currentBaseUrl) {
		currentBaseUrl = newBase;
		resetUI();
	}

	const ms = Math.max(200, Number(refreshMsInput.value) || 1000);
	timer = setInterval(poll, ms);
	poll();
}

applyBtn.onclick = start;
start();
</script>

</body>
</html>